/*
Симуляция обработки сетевых пакетов

Обработка сетевых пакетов
Реализовать обработчик сетевых пакетов.
Вход. Размер буфера size и число пакетов n, а также две последовательности arrival[1], ... , arrival[n] и duration[1], ... , duration[n], обозначающих время поступления и длительность обработки n пакетов.

Выход. Для каждого из данных n пакетов необходимо вывести время начала его обработки или −1, если пакет не был обработан (это происходит в случае, когда пакет поступает в момент, когда в буфере компьютера уже находится size пакетов).

Ваша цель — реализовать симулятор обработки сетевых пакетов. Для i-го пакета известно время его поступления arrival[i], а также время duration[i], необходимое на его обработку. В вашем распоряжении имеется один процессор, который обрабатывает пакеты в порядке их поступления. Если процессор начинает обрабатывать пакет i (что занимает время durationi ), он не прерывается и не останавливается до тех пор, пока не обработает пакет.

У компьютера, обрабатывающего пакеты, имеется сетевой буфер размера size. До начала обработки пакеты хранятся в буфере. Если буфер полностью заполнен в момент поступления пакета (есть size пакетов, поступивших ранее, которые до сих пор не обработаны), этот пакет отбрасывается и уже не будет обработан. Если несколько пакетов поступает в одно и то же время, они все будут сперва сохранены в буфер (несколько последних из них могут быть отброшены, если буфер заполнится). Компьютер обрабатывает пакеты в порядке их поступления. Он начинает обрабатывать следующий пакет из буфера сразу после того, как обработает текущий пакет. Компьютер может простаивать, если все пакеты уже обработаны и в буфере нет пакетов. Пакет освобождает место в буфере сразу же, как компьютер заканчивает его обработку.

Формат входа.
Первая строка входа содержит размер буфера size и число пакетов n. Каждая из следующих n строк содержит два числа: время arrivali прибытия i-го пакета и время durationi, необходимое на его обработку. Гарантируется, что arrival[1] <= arrival[2] <= ... <= arrival[n] . При этом может оказаться, что
arrival[i−1] = arrival[i]. В таком случае считаем, что пакет i − 1 поступил раньше пакета i.

Формат выхода.
Для каждого из n пакетов выведите время, когда процессор начал его обрабатывать, или −1, если пакет был отброшен.
Ограничения. Все числа во входе целые. 1 <= size <= 10^5; 0 <= n <= 10^5; 0 <= arrival[i] <= 10^6 ; 0 <= duration[i] <= 10^3 ; arrivali <= arrival[i+1] для всех 1 <= i <= n − 1.


Sample Input 1:
1 0
Sample Output 1:

Sample Input 2:
1 1
0 0
Sample Output 2:
0

Sample Input 3:
1 1
0 1
Sample Output 3:
0

Вход:
1 2
0 1
0 1
Выход:
0
-1
Первый пакет поступил в момент времени 0, второй пакет поступил также в момент времени 0, но был отброшен, поскольку буфер в этот момент полностью заполнен (первым пакетом). Первый пакет начал обрабатываться в момент времени 0, второй был отброшен.

Вход:
1 2
0 1
1 1
Выход:
0
1


1 25
16 0
29 3
44 6
58 0
72 2
88 8
95 7
108 6
123 9
139 6
152 6
157 3
169 3
183 1
192 0
202 8
213 8
229 3
232 3
236 3
239 4
247 8
251 2
267 7
275 7

Answer
16 29 44 58 72 88 -1 108 123 139 152 -1 169 183 192 202 213 229 232 236 239 247 -1 267 275

11 25
6 23
15 44
24 28
25 15
33 7
47 41
58 25
65 5
70 14
79 8
93 43
103 11
110 25
123 27
138 40
144 19
159 2
167 23
179 43
182 31
186 7
198 16
208 41
222 23
235 26

6 29 73 101 116 123 164 189 194 208 216 259 270 295 322 362 -1 381 -1 -1 -1 404 420 461 484

13 25
10 37
20 45
29 24
31 17
38 43
49 30
59 12
72 28
82 45
91 10
107 46
113 4
128 16
139 1
149 41
163 0
172 22
185 1
191 17
201 3
209 11
223 30
236 17
252 42
262 0

Answer

10 47 92 116 133 176 206 218 246 291 301 347 351 367 368 409 409 431 -1 -1 432 443 -1 473 -1


12 25
5 11
10 14
25 17
41 22
54 36
70 13
81 8
90 12
103 21
115 38
124 18
138 15
142 13
155 31
168 0
177 49
186 8
196 30
206 37
217 49
232 31
247 25
260 31
268 36
279 8

5 16 30 47 69 105 118 126 138 159 197 215 230 243 274 274 323 331 361 398 447 478 503 534 570


11 25
11 45
26 22
38 24
42 49
48 39
59 3
67 1
76 5
84 30
89 37
99 12
111 6
125 33
132 20
147 16
160 7
174 15
185 14
198 9
200 37
208 18
222 3
237 28
248 10
263 11

11 56 78 102 151 190 193 194 199 229 266 278 284 317 -1 337 -1 -1 344 353 390 408 411 -1 -1


1 25
15 23
24 44
39 43
48 15
56 6
56 8
56 29
56 28
56 4
56 17
68 44
75 22
75 34
84 46
84 21
84 25
97 31
105 34
105 43
117 17
129 12
142 47
144 22
144 18
152 9

15 -1 39 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 84 -1 -1 -1 -1 -1 -1 -1 142 -1 -1 -1



*/

const readline = require('readline');
const assert = require('node:assert');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: false,
});

let strI = 0;
let bufferSize = 0;
let packetsSize = 0;
const packets = [];

rl.on('line', (line) => {
    const d = line.split(' ').map((str) => Number(str));
    if (strI === 0) {
        bufferSize = d[0];
        packetsSize = d[1];
    } else {
        packets.push(d);
    }
    if (packetsSize === strI) {
        const workTime = getTimes(bufferSize, packetsSize, packets);
        for (const time of workTime) {
            console.log(time);
        }
    }
    strI += 1;
});
rl.once('close', () => {
});

const getTimes = (bufferSize, packetsSize, packets) => {
    // console.log(JSON.stringify({ bufferSize, packetsSize, packets }));

    if (!packetsSize) return [];

    const packetsTimes = new Array(packetsSize).fill(-1);
    const buffer = [];

    let currentTime = 0;
    let i = 0;
    while (i < packetsSize) {
        while (buffer.length < bufferSize && i < packetsSize) {
            const [ time, duration ] = packets[i];
            if (time < currentTime) {
                i += 1;
                continue;
            }

            buffer.push({
                time,
                duration,
                i,
            });
            i += 1;
        }

        if (buffer.length) {
            const firstPacket = buffer.shift();
            currentTime = currentTime > firstPacket.time ? currentTime : firstPacket.time;
            packetsTimes[firstPacket.i] = currentTime;
            currentTime += firstPacket.duration;
        }
    }

    while (buffer.length) {
        const firstPacket = buffer.shift();
        currentTime = currentTime > firstPacket.time ? currentTime : firstPacket.time;
        packetsTimes[firstPacket.i] = currentTime;
        currentTime += firstPacket.duration;
    }

    return packetsTimes;
};



const test = () => {
    assert.deepEqual(getTimes(1, 0, []), []);
    assert.deepEqual(getTimes(1, 1, [[0, 0]]), [0]);
    assert.deepEqual(getTimes(1, 1, [[0, 1]]), [0]);
    assert.deepEqual(getTimes(1, 2, [[0, 1], [0, 1]]), [0, -1]);
    assert.deepEqual(getTimes(2, 8, [[0,0],[0,0],[0,0],[1,0],[1,0],[1,1],[1,2],[1,3]]), [0, 0, 0, 1, 1, 1, 2, -1]);
};
test();
